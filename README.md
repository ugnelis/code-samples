# Code Samples

This repository contains various useful code samples.

## Java

### Algorithms

**Data Structures**

* [Linked List](java/algorithms/data_structures/LinkedList.java) is a data structure that represents a sequence of
  nodes. In a singly linked list, each node points to the next node in the linked list. A doubly linked list gives each
  node pointers to both the next node and the previous node.
* [Queue](java/algorithms/data_structures/Queue.java) a stack of data. In certain types of problems, it can be favorable
  to store data in a stack rather than in an array
* [Stack](java/algorithms/data_structures/Stack.java) uses LIFO (last-in first-out) ordering. That is, as in a stack of
  dinner plates, the most recent item added to the stack is the first item to be removed.

**Games**

* [Sudoku](java/algorithms/games/Sudoku.java) is a logic-based, combinatorial number-placement puzzle. In classic
  sudoku, the objective is to fill a 9×9 grid with digits so that each column, each row, and each of the nine 3×3
  subgrids that compose the grid contain all the digits from 1 to 9

**Graphs**

* [Breadth-First Search](java/algorithms/graphs/BFS.java) is an algorithm for searching a tree data structure for a node
  that satisfies a given property. It starts at the tree root and explores all nodes at the present depth prior to
  moving on to the nodes at the next depth level.
* [Depth-First Search](java/algorithms/graphs/DFS.java) is an algorithm for traversing or searching tree or graph data
  structures. The algorithm starts at the root node and explores as far as possible along each branch before
  backtracking.

**Math**

* [Greatest Common Divisor](java/algorithms/math/GCD_LCM.java) is the largest positive integer that divides each of the
  integers
* [Least Common Multiple](java/algorithms/math/GCD_LCM.java) is the smallest positive integer that is divisible by both
  a and b.
* [Sieve of Eratosthenes](java/algorithms/math/SieveOfEratosthenes.java)  is an ancient algorithm for finding all prime
  numbers up to any given limit.

**Recursion and Dynamic Programming**

* [Fibonacci](java/algorithms/recursion_and_dynamic_programming/Fibonacci.java) sequence is a set of numbers that starts
  with a one or a zero, followed by a one, and proceeds based on the rule that each number (called a Fibonacci number)
  is equal to the sum of the preceding two numbers.
* [Find number of sets that add up to given sum number](java/algorithms/recursion_and_dynamic_programming/FindSetsNumber.java)

**Searching**

* [Binary Search](java/algorithms/searching/BinarySearch.java) is a search algorithm that finds the position of a target
  value within a sorted array. Binary search compares the target value to the middle element of the array. If they are
  not equal, the half in which the target cannot lie is eliminated and the search continues on the remaining half, again
  taking the middle element to compare to the target value, and repeating this until the target value is found. If the
  search ends with the remaining half being empty, the target is not in the array.

**Sorts**

* [Bubble Sort](java/algorithms/sorts/BubbleSort.java) is a simple sorting algorithm that repeatedly steps through the
  list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated
  until the list is sorted.
* [Bucket Sort](java/algorithms/sorts/BucketSort.java) is a sorting algorithm that works by distributing the elements of
  an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting
  algorithm, or by recursively applying the bucket sorting algorithm.
* [Insertion Sort](java/algorithms/sorts/InsertionSort.java) is a sorting algorithm that places an unsorted element at
  its suitable place in each iteration.
* [Merge Sort](java/algorithms/sorts/MergeSort.java) is a divide-and-conquer algorithm. It divides the input array into
  two halves, calls itself for the two halves, and then merges the two sorted halves.
* [Quick Sort](java/algorithms/sorts/QuickSort.java) is a divide-and-conquer algorithm. It works by selecting a 'pivot'
  element from the array and partitioning the other elements into two sub-arrays, according to whether they are less
  than or greater than the pivot.
* [Radix Sort](java/algorithms/sorts/RadixSort.java) is a non-comparative sorting algorithm. It avoids comparison by
  creating and distributing elements into buckets according to their radix.

## JavaScript

### Projects

**Utility**

* [Open, scale, save image](javascript/utility/open_scale_save) in pure JavaScript.

**Cesium**

* [Check if an entity is visible](javascript/cesium/entity_is_visible)

### Cesium

## Python

### Computer Vision

**Projects**

* [Find ellipses in the image](python/computer_vision/find_ellipses/find_ellipses.py)

### Machine Learning

**Courses**

* [Udacity deep learning course](python/machine_learning/courses/udacity_deep_learning)

**Utility**

* [TensorFlow Deconvolution network](python/machine_learning/tensorflow/deconv/deconv.py)
* [TensorFlow image saving](python/machine_learning/tensorflow/image_saving/image_saving.py)

### Statistics

**Projects**

* [For a given data set X, predict its density function](python/statistics/density_function/predict_density_function.py)
